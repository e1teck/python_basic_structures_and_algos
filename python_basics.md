
<h2 style="text-align: center;"><b>Python. Занятие 1: Основы</b></h2>

<img align=left src="https://cdn.fedoramagazine.org/wp-content/uploads/2015/11/Python_logo.png" style="height:160px;" />

<img align=center src="https://1.bp.blogspot.com/-16utHnlB3Ao/V4tpG8NBX0I/AAAAAAAAA7M/vDQ1p40JpE8M34eCr-UdriSV04Dn8au7QCLcB/s1600/jupyter-logo.png" style="height:90px;" />

---


Перед тем как начать складывать уровни нейросеточек как блинчики или предсказывать кредитоспособность клиентов, нужно быть хорошо знакомым с нужными библиотеками и языком, на котором они написаны. 
В нашем курсе мы будем использовать язык **Python**, так как он является оптимальным сочетанием простоты, силы и количества полезных библиотек, написанных для него. 

На этом занятии мы научимся писать программы на Python, изучив его основы.  

## Основы Python

Сейчас существуют две часто используемые версии Питона — **Python 2** и **Python 3**. Эти версии довольно похожи, но есть отличия, из-за которых они **не являются совместимыми** - программы, написанные на одной версии языка, могут не работать в другой.  

В нашем курсе мы будем писать на **Python 3**. Точная версия не принципиальна, но она должна быть >= 3.5  

Если Вы пользуетесь каким-либо из дистрибутивов Linux, то Python скорее всего уже установлен.
Попробуйте в терминале следующие команды для запуска интерактивного режима работы:

`python` или `python3` или `python2`

Выход: `Ctrl+D`

Режим работы, в котором выполнится код из файла main.py

`python main.py`

Помощь: **`help(X)`**, где `X` — то, по чему нужна помощь.  
Выход из помощи: `q`.

## Общая информация о языке

**Название** - **«Питон» или «Пайтон»** (в честь комедийных серий BBC «Летающий цирк Монти-Пайтона»)  
**Создатель** - **голландец Гвидо ван Россум (Guido van Rossum)** (в 1991 году)  

**Особенности**:  
- интерпретируемый
- объектно-ориентированный
- высокоуровневый язык
- встроенные высокоуровневые структуры данных
- динамическая типизация
- синтаксис прост в изучении
- поддержка модулей и пакетов (большинство библиотек
бесплатны)
- универсальный
- интеграция с другими языками (C (Cython), C++, Java (JPython))  

**Стиль оформления кода** - **PEP8** (если Вы хороший человек).  

*Самое главное из PEP8:*  
- отступ – 4 пробела
- длина строки < 80 символов
- переменные: var_recommended
- константы: CONST_RECOMMENDED

## Список материалов для самостоятельного изучения

Данный ноутбук не претендует на полный охват всех тем и нюансов языка, поэтому ниже для удобства предоставлены ссылки на внешние ресурсы, которые могут помочь лучше изучить язык:

* *Сайт языка Python* - https://www.python.org/


* *Базовый курс синтаксиса Python с практикой* - https://www.codecademy.com/learn/learn-python


* *Курс Python с нуля, можно выполнять задания в интерактивном режиме* - http://pythontutor.ru/


* *Очень много задач на практику из разных областей, сделано по типу соцсети* - https://codesignal.com


* *Новый онлайн-курс по Питону на Coursera от Mail.Ru Group* - https://www.coursera.org/learn/programming-in-python


* *Самоучитель Python* - https://pythonworld.ru/samouchitel-python


* *Статья про коварности Python* - https://habrahabr.ru/company/mailru/blog/337364/


* *Очень полезные трюки в Jupyter Notebook*: https://www.dataquest.io/blog/jupyter-notebook-tips-tricks-shortcuts/

### Типы

**Все типы данных** в Python относятся к одной из **2-х категорий**: **изменяемые (mutable)** и **неизменяемые (immutable)**.   

*Неизменяемые объекты*:  
* числовые данные (int, float), 
* bool,
* None,
* символьные строки (class 'str'), 
* кортежи (tuple).  

*Изменяемые объекты*:  
* списки (list), 
* множества (set), 
* словари (dict).  

Вновь определяемые пользователем типы (классы) могут быть определены как неизменяемые или изменяемые. Изменяемость объектов определённого типа является принципиально важной характеристикой, определяющей, может ли объект такого типа **выступать в качестве ключа для словарей (dict)** или нет.

----------

Начнем наше знакомство с языком с примитивных типов переменных:

### int

**Целочисленный тип переменной в питоне**

Чтобы задать переменную, не нужно указывать ее тип -- достаточно присвоить ей значение. При этом тип определится автоматически.

Давайте попробуем завести переменную, присвоить ей значение -- целое число, и вывести на экран ее значение и тип (type):


```python
x = 5

print(x, '|', type(x))
```

Как видно, тип получившейся переменной -- int.

C int'овыми переменными можно производить стандартные матеатические операции -- сложение, вычитание, умножение, деление, возведение в степень, взятие остатка при делении на число

Деление переменных типа int бывает двух типов -- целочисленное (с помощью символа //) и нецелочисленное (символ /). Результатом первого типа деления будет целое число, второго -- дробное. 


```python
a = 4 + 5
b = 4 * 5
c = 5 // 4
d = 5 / 4
e = 5**4 # 5 в степени 4
f = 5%4 # остаток при делении 5 на 4

print(a, b, c, d, e)
```

Также язык питон удобен в работе с большими числами:

Давайте попробуем положить в переменную число 5000000000000000000000000001:


```python
x = 5 * 1000000000 * 1000000000 * 10**9 + 1
print(x, '|', type(x))
```

Как видите, все получилось: полученная переменная типа int и с ней можно работать как с обычными числами. Во многих других языках (например, С++) положить такое большое число в переменную бы не вышло -- возникло бы переполнение.

### float

**Тип переменной для хранения дробных чисел в питоне**:


```python
y = 12.345

print(y, '|', type(y))
```

С этим типом также можно выполнять арифметические операции (даже целочисленное деление):


```python
a = 4.2 + 5.1
b = 4.2 * 5.1
c = 5.0 / 4.0
d = 5.25 // 4.25
e = 5.25 ** 4.0

print(a, b, c, d, e)
```

Переменную типа int можно привести к типу float 


```python
a = 5
print(a, '|', type(a))
a = float(a)
print(a, '|', type(a))
```

### bool

**Логический тип переменной**: 

переменная типа bool может принимать два значения: `True` и `False`:


```python
a = True
b = False

print(a, '|', type(a))

print(b, '|', type(b))
```

У типа bool существует связь с типом int -- переменная со значением True соответствует int'овой переменной со значением 1, а переменная со значением False -- int'овой переменной со значением 0.

Давайте в этом убедимся, попробовав сложить значения переменных a и b:


```python
print(a + b)
print(a + a)
print(b + b)
```

Ну и просто приведем a и b к типу int:


```python
print(int(a), int(b))
```

Логические "и", "или", "не" в питоне обозначаюся ключевыми словами `and`, `or`, `not` соответственно:


```python
print(True and False, '\n')

print(True or True, '\n')

print(not False, '\n')
```


```python
# в переменную a будет записан результат сравнения 2 и 3. т.е. False, потому что (2==3) неверно. 
a = (2 == 3)
b = (4 < 5)

print(a, '|', type(a))
print(b, '|', type(b))
```


```python
a or (a and not b)
```

### If

**Условный оператор**

В коде часто приходится проверять выполнимость или невыполнимость каких-то условий. Синтаксис следующий

```
if <условие1 (булевское выражение)> :
    <код, который выполнится, если условие верно>
elif <условие2 (булевское выражение)>:
    <код, который выполнится, если условие1 было неверно, а условие2 верно>
else:
    <код, который выполнится, если условие1 и условие2 были неверны>
```

Обратите внимание, что код, который должен выполняться внутри каждого условия, записывается с отступом в 4 пробела от уровня if, elif и else: в питоне области видимости переменных обозначаются отступами.

*То есть, отступы позволяют понять, где начинается код, который должен выполняться при выполнении условия в if, и где заканчивается*

Рассмотрим пример: пусть в нашем коде есть переменная x. Пусть мы хотим вывести на экран сообщение "x отрицателен", если x<0, "x равен нулю", если x=0 и "x положителен", если x>0. Код будет следующий:


```python
x = 10

if x<0:
    print("x отрицателен")
elif x==0:
    print("x равен нулю")
else:
    print("x положителен")
    
# этот код уже не "внутри" else, потому что записан без отступа в 4 пробела. Поэтому он выполнится 
# в любом случае после отработки if-elif-else
print("Done")
```

Конечно, в `if` можно подставлять и более сложные булевские выражения:


```python
if x>3 and x < 11 or x==5:
    print(x)
    # тоже выполнится при выполнения условия после if, так как этот код тоже записан с отступом в 4 пробела
    print("nice")
```


```python
# if внутри if:
x = 3
y = 5
if x == 3:
    if y > 6:
        # отступ в 4 пробела от внутреннего if
        print("y greater than 6")
    else:
        print("y not grater than 6")
        
    # отступ в 4 пробела от внешнего if, поэтому код выполнится если x==3 и при любом значении y
    print("x is equal to 3")
```

### None

**ничего, null**

Специальный тип в питоне, который обозначает *ничего*

Его нельзя привести ни к одному другому типу языка. Проверить, является ли переменная param типом None, можно так:

```
if param is None
```

С первого взгляда может быть непонятно, зачем он нужен, но на самом деле это оченб удобный тип. Например, если вы где-то в коде создаете объект (базу данных, например), обращаясь к внешнему коду и хотите проверить, создалась ли ваша база данных, вы можете осуществить эту проверку, сравнив переменную базы данных с None. Примерно так:

```
database = MyDatabase(db_host, db_user, db_password, db_database)

if database is None:
```


```python
z = None
print(z, '|', type(z))
```

Убедимся, что None нельзя привести к другому типу:


```python
int(z)
```

Проверка переменной на None:


```python
if z is None:
    z = 'I am None!'
z
```

### str

**строка**

Тип переменной "строка". Нужен для хранения и выполнения операций с строками -- наборами символов. В питоне строку можно задавать как с помощью одинарных кавычек, так и с помощью двойных, разницы нет (главное, чтобы в начале и конце одной строки стояли одинаковые кавычки):

В *python2.7* есть отдельный тип **unicode**. В *python3.5 (и выше)* (который будем использовать мы) всё это включено в тип **str**.


```python
x = "abc"
y = 'xyz'
print(x, '|', type(x))
print(y, '|', type(y))
```

Со строками тоже можно выполнять некоторые операции. Например, можно сложить две строки -- тогда вторая припишется в конец первой:


```python
a = 'Андрей'
b = "Михайлович"
s = a + " " + b
print(s)
```

Также у строк есть некоторое количество *методов*

Метод -- это название для функций, которые вызываются от объекта. Например, у нас есть объект a -- строка, и у нее можно вызвать метод `.upper()`:

```
a.upper()
```

Методы деляится на те, которые изменяют сам объект, который их вызывает, и на те, которые возвращают результат, но не изменяют сам объект. 

Вот пример методов `.upper()` и `.lower()`, которые возвращают копию строки (не изменяя саму строку), от которой был вызван метод, приведенную к верхнему и нижнему регистру соответственно:

P.S. При вызове метода какого-то класса (или функции какого-то модуля) можно написать его имя и через точку нажать **tab**:  

<имя\_объекта\_класса(модуля)>**.[tab]**  

Тогда всплывёт меню, в котором можно выбрать из всех существующих в этом классе методов (функций модуля).


```python
print(a.upper())
print(a.lower())
```

Можно получить длину строки с помощью функции `len`:


```python
print(len(a))
```

Можно обращаться к отдельным элементам строки через индексы (индексация в питоне с 0):


```python
print(a)
print(a[0])
print(a[1])

```

А также можно получить *слайс* строки -- кусок строки с i-ого символа по j-ый. Делается это следующим образом:


```python
i = 0
j = 1
print(a[i:j])
```

Можно проверять наличие подстроки в строке:


```python
s = 'ya stroka'
if 'ya' in s:
    print("ya deistvitel\'no stroka")
```

А вот изменять уже существующие строки нельзя:


```python
s = 'ya stroka'
s[0] = 'l'
```

### Метод `split()`:

У строк наряду с методами `.upper()`, `.lower()` и остальными есть метод `.split()`, который часто бывает очень полезен. Этот метод делит строку на несколько по символу, который ему указываешь, и возвращает набор полученных строк (точнее, массив полученных строк -- о том, что такое массив, ниже)

Если символ не указывать, строка делится по пробелам:


```python
splitted_line = "Райгородский Андрей Михайлович".split()
print(splitted_line)
```


```python
splitted_line = "Райгородский Андрей Михайлович".split('р')
print(splitted_line)
```

### Структуры данных и встроенные функции

### list

**массив, список, лист**

Вот мы и добрались до типов языка python, которые представляют собой *контейнеры*, то есть, это типы данных, которые являют собой хранилища для других типов данных.

Один из таких типов -- `list` (массив, список, лист). Это контейнер, куда можно положить сколько угодно других переменных, значений, и эти переменные даже могут быть разных типов и даже так же могут быть контейнерами! То есть, в list можно положить list:

Чтобы задать list, надо в квадратные скобки `[]` положить нужные элементы. Пустые скобки задают пустой list. Пустой лист также можно задать, написав `list()`:


```python
a = list()
b = []

# убедимся, что два варианта создания пустого массива эквивалентны:
print(a == b)
```


```python
c = [2, 'a', [4, 'stroka', 6.56]]
```

Что можно делать с list:

Можно положить элемент в конец массива:


```python
c.append(4.67)
c
```

можно удалить элемент с конца массива:


```python
c.pop()
c
```

**Методы list, которые мы рассмотрим ниже, будут работать для всех iterable контейнеров **

(что значит iterabel, можно прочитать тут: http://pythonz.net/references/named/iterable/

кратко -- это структуры данных, поддерживающие поочередный проход по своим элементам)

По индексам можно получить доступ к элементам массива (индексация, как обычно, с 0):


```python
print(c[0])
print(c[2])
# да, индексы могут быть отрицательные: -i есть i-ый с конца элемент массива (в нумерации с 1)
print(c[-1])
```

Можно не только получать по 1 элементу массива, но и *слайс* -- элементы массива с индексами между i (включительно) и j (не включительно):


```python
# в d будет записан новый массив, в котором будут 1 и 2 элементы массива c
d = c[1:3]
print(d)
```

А еще можно сделать операцию наоборот -- не по индексу получить элемент массива, а по элементу массива получить его индекс.

`L.index(element)` - возвращает индекс элемента `element` в списке `L`, если он там присутствует, `None` иначе (вот еще один пример использования None)


```python
c.index('a')
```

Можно проверять принадлежность элемента массиву:


```python
5 in c
```


```python
if 'a' in c:
    print("element \'a\' in c")
```

Можно еще сложнее: получить каждый k-й элемент массива c, начиная с элемента с индексом i (включительно) и заканчивая элементом с индексом j (не включительно):


```python
c = [1, 2, 3, 4, 5, 6, 7, 8, 9]
d = c[1:7:2]
print(d)
```

С помощью слайсов можно перевернуть массив, например:


```python
print(c)
# получим каждый минус первый элемент массива начиная с 0 индекса и заканчивая последним
d = c[::-1]
print(d)
```

Элементы массива также можно изменять, обращаясь к ним по индексу или слайсу:


```python
print(c)
c[0] = 100500
print(c)
```


```python
# вместо 2, 3 и 4 элементов массива запишем  число 80
c[2:5] = [80]
print(c)
# вместо 2, 3 и 4 элементов массива запишем  числа 80, 90
c[2:5] = [80, 90]
print(c)
```

Также массивы можно складывать. Результатом сложения двух массивов будет новый массив, в котором сначала будут записаны элементы первого массива, затем -- второго:


```python
d = [9, 0]
c+d
```

А вот вычитать нельзя:


```python
c-d
```

С помощью `len()` можно получить размер листа (и вообще любого iterable объекта):


```python
len(c)
```

можно отсортировать элементы массива, вызвав метод .sort():


```python
# вызов метода sort изменяет сам объект c, а не возвращает копию:
c.sort()
c
```

### Задание 1

Напишите код, который проверяет, является ли переменная x строкой, и если да, то если в строке больше одного слова (слово--последовательность подряд идущих символов без пробелов), то выводит на экран количество слов в этой строке и сами слова в алфавитном порядке


```python
# your code here
```

### Задание 2

Напишите код, который все элементы массива x с **нечетными** индексами переставит в обратном порядке.

Т.е. если x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], то код должен получать [0, 9, 2, 7, 4, 5, 6, 3, 8, 1]


```python
# your code here
```

### tuple

**кортеж**

этот тип данных очень похож на list, имеет ту же структуру, но отличается тем, что он неизменяемый

это нужно, например, чтобы `tuple` мог выступать в качестве ключей словаря (о них ниже). list в качестве ключей словаря выступать не может.

Задать tuple можно круглыми скобками:


```python
t = ('a', 5, 12.345, (2, 'b'))
t
```

Tuple нельзя изменять. Давайте в этом убедимся:


```python
t.append(5)
```


```python
t[0] = 9
```

Но получать элементы по индексу и слайсам, конечно, можно (tuple же iterable):


```python
print(t[2])
print(t.index(5))
print(t[:2])
```

Как и list, кортежи можно складывать и работает сложение так же, как в list 

(вообще, с кортежами можно делать все, что можно делать с list, если это не изменяет кортеж)


```python
m = (1, 2, 3)
# складывать
print(t + m)
# узнать размер 
print(len(t))
# проверить наличие элемента
print(5 in t)
```

---

### Циклы - for и while

iterable стректуры данных так называются, потому что по ним можно *итерироваться* -- последовательно получать значения последовательных элементов этой структуры данных. Итерироваться можно с помощью циклов `for` или `while`.

Синтаксис следующий:

```
for element in iterable:
    <code>
```

здесь каждую новую итерацию цикла в element будет записываться очередное значение из контейнера iterable и с ним можно будет работать внутри тела цикла (`code`). Когда код внутри тела цикла отработает, начнется новая итерация цикла -- в переменную element запишется следующее значение из iterable и опять будет выполняться code.

Код, который будет выполняться каждую итерацию цикла, записывается после двоеточия с отступом 4 пробела от строчки c `for`.

Посмотрим на примере:


```python
# создадим list элементов
models = ['decision tree', 'linear model', 'svm', 'ensemble']

# итерируемся по названиям модели: каждую итерацию цикла в переменную model будет
# записываться новое значение из models и оно будет использоваться для print(model)
for model in models:
    # тело цикла. Здесь с отступом в 4 пробела нужно описать код, который будет выполняться на каждой итерации цикла.
    print(model)
    
# этот код уже будет выполняться ПОСЛЕ цикла, потому что он записан без отступа в 4 пробела после for:
print("Done")
```

**P.S.** Зметим, что каждую итерацию цикла в переменную model **копируется** очередное значение из models. Это значит, что если вы внутри цикла измените переменную model, соответствующее значение в массиве models изменено **не будет**

Синтаксис `while`:

```
while <условие (булевское выражение)>:
    <code>
```

Здесь код, написанный вместо `code` будет выполняться каждую итерацию цикла, пока условие после `while` будет выполняться.

Посмотрим на примере: Напишем цикл, в котором будем выводить переменную x и увеличивать x на 1, пока x не станет больше 10:


```python
x = 1

while x <= 10:
    print(x)
    # более удобный способ записи x = x + 1
    x += 1
```

Иногда бывает нужно прервать выполнение цикла при выполнении какого-то условия

Например, мы хотим итерироваться по массиву строк, на каждой итерации выводить строку на экран и прервать цико (перестать выводить строки), если мы встретили строку stop.

Это делается с помощью ключевого слова `break`:


```python
mas = ['stroka1', 'stroka2', 'stroka3', 'stop', 'stroka4']

for s in mas:
    if s == 'stop':
        break
    print(s)
```

Иногда же хочется не прервать выполнение всего цикла, а прервать выполнение именно одной итерации цикла и продолжить цикл со следующей итерации.

Например, мы так же, как в предыдущем примере, хотим итерироваться по массиву строк и выводить строку на каждой итерации на экран, но не хотим выводить строку на экран, если эта строка равна 'null'.

Это делается с помощью ключевого слова `continue`:


```python
mas = ['stroka1', 'null', 'stroka3', 'stop', 'null']

for s in mas:
    if s == 'null':
        continue
    print(s)
```

#### range

Для работы с циклами в питоне есть очень полезная функция `range()`. Допустим, вы хотите написать цикл, который бы отработал 100 раз. Можно сделать это следующим образом:

```
i = 0
while i < 100:
    i += 1
    <code>
```

но это неудобно: нужно завести вспомогательную переменную i, написать лишние 2 строчки кода (i=0 и i+=1). Так код терядет в понятности и читабельности. Гораздо проще записать этот цикл с помощью range.

`range()` принимает 3 аргумента: начало интервала begin, конец интервала end и шаг step, с которым будет двигаться по игтервалу, и возвращает iterable объект -- по сути, массив чисел начиная с begin включительно, заканчивая end не включительно, числа в массиве идут с шагом step.

Посмотрим на пример:


```python
r = range(1, 100, 10)
#приведем возвращаемый iterable к list и выведем на экран:
print(list(r))
```

Теперь легко записать цикл:


```python
for i in range(1, 100, 1):
    print(i)
```

Если у range не указывать последний алгумент step, он по умолчанию будет 1.

А если указать всего один аргумент, то range выдаст iterable с началом в 0 и концом в этом аргументе:


```python
list(range(4, 8))
```


```python
list(range(8))
```

С помощью range нетрудно переписать цикл, который мы писали выше, где итерировались по названиям моделей, так, чтобы элементы массива models  можно было изменять внутри цикла:


```python
# создадим list элементов
models = ['decision tree', 'linear model', 'svm', 'ensemble']

# итерируемся по индексам массива models
for i in range(len(models)):
    # тут если вы поменяете models[i], то значение в models тоже изменится
    print(models[i])
    
# этот код уже будет выполняться ПОСЛЕ цикла, потому что он записан без отступа в 4 пробела после for:
print("Done")
```

### Задание 3

Напишите цикл, который выводит все числа от 0 до 500, делящиеся на 7, если в них есть цифра 8

*Подсказка*: переменную типа int можно привести к типу str:
```
x = 5
y = str(x)
```


```python
# your code here
```

---

### enumerate, zip

`zip()` принимает два iterable аргумента и возвращает iterable из пар соответствующих элементов этих двух iterable:


```python
first = 'a b c d e f g'.split(' ')
second = '1 2 3 4 5 6 7'.split(' ')

list(zip(first, second))
```

Что будет, если один из iterable короче, чем другой:


```python
first = 'a b c d e f g'.split(' ')
second = '1 2 3 4 5'.split(' ')

list(zip(first, second))
```

Это опять же полезно для использования в циклах:


```python
models = ['decision tree', 'linear model', 'svm', 'ensemble']

# zip dвозвращает пару элементов, которые можно записать в 2 разные переменные в цикле for. 
# например, здесб мы записываем первый элемент пары в num, второй -- в model.
for num, model in zip(range(len(models)), models):
    print(str(num+1)+'\'s model is:', model)
```

Однако в этом коде мы хотели просто пронумеровать элементы списка models, но нам для этого пришлось писать zip(range(...))

Именно для такого случая, когда надо пронумервать элементы какого-то iterable, существует функция `enumerate`:

`enumerate(iterable)` возвращает пары номер-элемент iterable:


```python
models = ['decision tree', 'linear model', 'svm', 'ensemble']

# zip dвозвращает пару элементов, которые можно записать в 2 разные переменные в цикле for. 
# например, здесб мы записываем первый элемент пары в num, второй -- в model.
for num, model in enumerate(models):
    print(str(num+1)+'\'s model is:', model)
```

---

### Задание 4

1. Создайте список `a`, состоящий из каких-то элементов.
2. Создайте список `b` такого же размера, как `a`, состоящий из каких-то элементов.
3. Выведите **нумерованный список пар** из элементов списков `a` и `b`.


```python
# Ваш код здесь
```

---

### set

**Множество**

Множество -- это массив, в котором элементы не могут повторяться (то есть, как и в математическом определении множества)

Внутри языка множество устроено совсем не так, как массив или кортеж, элементы множества хранятся не последовательно, поэтому к элементам множества нельзя обрашаться по индексу.

Пустое множество можно создать с помощью set():


```python
s = set()

print(s, '|', type(s))
```

А можно привести список к множеству:

Обратите внимание, что элементы set'а выводятся в отсортированном порядке!


```python
s = set([5, 2, 3, 2])
s
```

Можно добавлять элементы в множество с помощью метода `.add()`:


```python
s.add(1)
s.add('a')
# None тоже можно добавить =)
s.add(None)
s.add('bullet')
print(s)
```

Метод .difference() позволяет получить элементы, которые есть в одном сете, но нет в другом:


```python
s1 = set(range(0, 10))
s2 = set(range(5, 15))

print('s1: ', s1, '\ns2: ', s2)
```


```python
# элементы, которые есть в s1, но нет в s2
print(s1.difference(s2))
print()
# элементы, которые есть в s2, но нет в s1
print(s2.difference(s1))
```


```python
# пересечение множеств s1 и s2 можно записать двумя способами:
print(s1.intersection(s2))
print(s1 & s2)
```


```python
# объединение множеств s1 и s2 тоже можно записать двумя способами:
print(s1.union(s2))
print(s1 | s2)
```

Из сета можно удалить элемент по значению:


```python
s1.discard(0)
s1
```

### dict

**словарь, ассоциативный массив**

Словарь -- это структура данных, которая представляет отображение из одного типа данных в другой. Представляет собой набор пар ключ-значение, в качестве ключа могут выступать immutable типы данных (int, str, tuple, ...)

Массивы, которые мы до этого рассматривали, были отображением непрерывного отрезка [0, n] в другой тип данных. `dict` может быть гораздо удобнее, когда нужно использовать в качестве ключа другой тип данных (например, сопоставить именам людей (str) их даты рождения) или когда в качестве ключа хочется использовать int, но не все значения из промежутка [0, n] нужны. Например, если хочется сопоставить года рождения великих писателей их именам. 

Пустой словарь можно создать либо с помощью `{}`, либо с `dict()`:


```python
d = {}
dd = dict()

print(d == dd, '|', type(d))
```

Добавим значение value по ключу key в словарь:


```python
key = 'a'
value = 100

d[key] = value
d
```

Непустой словарь можно создать несколькими способами:


```python
d = {
    'short': 'dict',
    'long': 'dictionary'
}
d
```


```python
d = dict(short='dict', long='dictionary')
d
```


```python
d = dict([(1, 1), (2, 4)])
d
```

Создать дефолтный словарь с ключами из списка, значениями None:


```python
d = dict.fromkeys(['a', 'b'])
d
```

Создать дефолтный словарь с ключами из списка, всеми значениями по умолчанию 100:


```python
d = dict.fromkeys(['a', 'b'], 100)
d
```

**dict comprehensions**

Еще один способ объявления словаря: создадим словарь, где каждому целому числу от 0 до 6 поставим в соответствие квадрат этого числа:


```python
d = {a: a ** 2 for a in range(7)}
d
```

### !

Будьте осторожны, если ключа, по которому поступил запрос, нет в словаре, то выбросит исключение:


```python
d = {1: 100, 2: 200, 3: 300}
d['a']
```

Поэтому безопаснее использовать **get(key)**. Тогда, если нужно, можно проверить на **None**:


```python
d.get(1)
```


```python
d.get('a') == None
```

Самое часто используемое - получение ключей, получение значений и получение всего вместе:


```python
# получить список ключей
print(d.keys(), '|', type(d.keys()))

# чтобы вывести ключи, нужно привести d.keys() к списку
print(list(d.keys()))
```


```python
# получить список значений
print(d.values(), '|', type(d.values()))

# то же самое -- чтобы вывести значения, нужно привести d.values() к списку
print(list(d.values()))
```


```python
# получить список пар ключ-значение
print(d.items(), '|', type(d.items()))

# то же самое -- чтобы вывести пары ключ-значения, нужно привести d.items() к списку
print(list(d.items()))
```


```python

```

---

### Задание 5
Дан массив строк mas. Одной строкой создайте словарь, в котором по ключу строки будет записана пара (кортеж длины 2) (индекс строки в массиве mas, длина строки)


```python
# Ваш код здесь
```

### modules

**Модули** - это "библиотеки" Python. То есть это самостоятельные, объединённые технически и логически, именованные части Python кода

Можно рассматривать их как код, функции, записанные в других файлах (модулях), и чтобы использовать их в своем коде, нужно подключить эти файлы (модули)

* О модулях необходимо знать только одно - как их импортировать:


```python
import collections
```

* Импортировать только какой-то компонент из модуля:


```python
# импортируем структуру данных Counter из библиотеки collections
from collections import Counter
```

* Импортировать с другим именем (чаще всего используется для локаничности кода):


```python
import collections as cool_lib
```


```python
count = cool_lib.Counter()
```

Жизненный пример:


```python
import numpy as np
```


```python
На этом самый базовый ноутбук закончен. Если здесь что-то было непонятно/не хватило информации по какой-то из освеченных тем, можно перейти по ссылкам в начале ноутбука и изучить больше!
```


```python

```
